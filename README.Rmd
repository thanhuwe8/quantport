---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# quantport

The package `quantport` provides routines to perform portfolio optimization based on quadratic and sequential programming. With Sharpe Ratio maximization problem (tangency portfolio), the lower boundary and upper boundary for any single asset, as well as other constraints could be implemented using Sequential Programming.

The main advantage of this package is easy-to-use and simplicity. The package is based purely on functional programming. You do not need to create object like S3 or S4 to run portfolio optimization. The result from optimization will be stored in dataframe or list only. The mean vector and the covariance matrix could be used from daily, monthly or quarterly data. The package could be used in complement with your master studies in portfolio optimization or courses such as CFA, FRM, etc.

# Plan for development
In the near future, we will add further functionalities including Differential Evolutionary Optimization (DE) and Canonical Black-Litterman model.

## Installation
There are several packages required: `quadprog`, `DEoptim`, `NlcOptim`, `ggplot2` and `tidyverse`.
We plan to submit this package to [CRAN](https://CRAN.R-project.org) in the near future. At the mean time, the package could be downloaded via github using `devtools`:

``` r
devtools::install_github("thanhuwe8/quantport")
```

## Example

This is a basic example which shows you how to solve the portfolio optimization problem. We have the data in the form of data.frame with 10 assets monthly return as below:

```{r example, echo=FALSE}
library(quantport)
library(knitr)
library(ggplot2)
```

```{r example2}
data(dataset1)
kable(head(dataset1,3))
```

Then we calculate 2 required inputs for portfolio optimization as follows:

```{r inputs, }
data_test <- dataset1[,-1]
mean_vec <- apply(data_test, MARGIN=2, mean)
cov_mat <- cov(data_test)
kable(mean_vec)
kable(cov_mat)
```

Then we provide necessary inputs to the `TangencyQP` to find the weight of optimal portfolio with maximum Sharpe Ratio. 

```{r TangencyQP}
tangency_result <- quantport::TangencyQP(ret=mean_vec,covmat=cov_mat,short=T,rf=0,freq="monthly") 
optimal_weight <- data.frame(tangency_result$weight)
```

```{r barplot, echo=FALSE, dpi=400}
ggplot()+geom_bar(aes(x=rownames(optimal_weight),y=optimal_weight[,1]), stat='identity', fill="#DE892C")+
    xlab("Asset")+ylab("Weight")+ggtitle("Tangency Portfolio without short-selling constraint")
```

Portfolio return and standard deviation are also stored and accessed using `$` operator

```{r }
print(tangency_result$portfolioret)
print(tangency_result$portfoliosd)
print(tangency_result$SharpeRatio)
```

There are other useful functions you could find in the vignettes of this package. Below is the efficient frontier with short-sale constraints. The dots to the right of the curve is single asset risk-return trade-off point. The red dot is tangency portfolio and the green dot is minimum variance portfolio. Mean return and standard deviation are both annualized assuming 252 trading days.

```{r efficient, dpi=400}
ef <- quantport::showEfficient(ret=mean_vec,covmat=cov_mat,short=F,rf=0.05,freq="monthly",simpoints=200,assetpoints=T) 
```

The weight of all popular porfolio could be calculated using `UltimateWeight` function as below:

```{r ultimate, dpi = 400}
final_result <- UltimateWeight(ret=mean_vec,covmat=cov_mat, short=T,target=0.08,rf=0,freq="monthly")
kable(round(final_result[[1]],4))
kable(final_result[[2]])
```











